#
# Copyright (C) 2011 Network Security Services, LLC
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation version 3 of the
# License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# evt_plugin.py
# David Windsor <dwindsor@networksecurityservicesllc.com>
# 
# Windows Event Log file format definitions
# Specification taken from:
# http://msdn.microsoft.com/en-us/library/windows/desktop/bb309026(v=vs.85).aspx
#

import plugin
import time

# EVT logfile header magic numbers
evt_header_magic['size'] = "0x30"             # Size of header structure
evt_header_magic['signature'] = "0x654c664c"  # Header signature
evt_header_magic['majorVersion'] = "1"        # Major version of event log
evt_header_magic['minorVersion'] = "1"        # Minor version of event log
evt_header_magic['endSize'] = "0x30"          # Ending size of header structure

class EvtPlugin(plugin.Plugin):
"""A carver plugin for reading Windows Event Log Files"""
    _name = "evt"
    _bs = pass          # ConstBitStream for scanning unalloc space
    _records = []       # A list of the EVT records found
    _log = EvtLog()     # An log object to hold all of the found records

    def searchFile(self, dataFile):
    """Search data for EVT log files. Return a tuple off header lists and
       record lists"""
        try:
            _bs = open(data, "r")
        except IOError:
            print "Unable to open file " + data + ": " + strerror
            return -1

        headers = []
        records = []

        # Find all occurrences of the magic string
        found = _bs.findall(magicString, bytealigned=False)
        for idx in found:
            _bs.pos = idx
            r = EvtRecord()
            r.setPosition(_bs.pos)

            # Message length
            readBits = 32
            lenIdx = idx - readBits     # Set stream position to idx of length
            _bs.pos = lenIdx
            length = _bs.read(readBits).uintle
            r.setField("length", length)

            # Reset stream position
            _bs.pos = idx

            # Message separator
            readBits = 32
            sep = _bs.read(readBits).uint
            r.setField("reserved", sep)

            # Record number
            readBits = 32
            recordNum = _bs.read(readBits).uintle
            r.setField("recordNumber", recordNum)

            # Date created
            readBits = 32
            created = _bs.read(readBits).uintle
            r.setField("timeGenerated", time.ctime(created))

            # Date written
            readBits = 32
            written = _bs.read(readBits).uintle
            r.setField("timeWritten", time.ctime(written))

            # Event ID
            readBits = 32
            eventID = _bs.read(readBits).uintle
            r.setField("eventID", eventID)
          
            # Event type
            readBits = 16
            eventType = _bs.read(readBits).uint
            r.setField("eventType", eventType)

            # Num strings
            readBits = 16
            numStrings = _bs.read(readBits).uint
            r.setField("numStrings", numStrings)

            # Category
            readBits = 16
            category = _bs.read(readBits).uint
            r.setField("eventCategory", category)

            # Reserved flags 
            readBits = 16
            flags = _bs.read(readBits).uint
            r.setField("reservedFlags", bits)

            # Closing record number
            readBits = 32
            recordNum = _bs.read(readBits).uint
            r.setField("closingRecordNum", recordNum)

            # String offset
            readBits = 32
            stringOffset = _bs.read(readBits).uint
            r.setField("stringOffset", stringOffset)

            # User SID length
            readBits = 32
            sidLength = _bs.read(readBits).uint
            r.setField("userSigLength", sidLength)

            # User SID offset
            readBits = 32
            sidOffset = _bs.read(readBits).uint
            r.setField("userSidOffset", sidOffset)

            # Data length
            readBits = 32
            dataLength = _bs.read(readBits).uint
            r.setField("dataLength", dataLength)

            # Data offset
            readBits = 32
            dataOffset = _bs.read(readBits).uint
            r.setField("dataOffset", dataOffset)
            
            # 2 unknown fields
            #readBits = 16
            #null = _bs.read(readBits).bytes

            # Event type
            #readBits = 8
            #eventType = _bs.read(readBits).uint
            #r.setField("eventType", eventType)

            # String count
            #readBits = 16
            #strCount = _bs.read(readBits).uint
            #r.setField("numStrings", strCount)

            # Category
            #readBits = 16
            #category = _bs.read(readBits).uint
            #r.setField("eventCategory", category)

            # SID
            #readBits = 64
            #sid = _bs.read(readBits).uint
            #r.setField("sid", sid)
        
            # 2 unknown fields
            #readBits = 19
            #null = _bs.read(readBits.bytes)

            # Source name
            #readBits = 32
            #sourceName = _bs.read(readBits).bytes
            #r.setField(

            _records.append(r)
        return (headers, records)

    def parseLog(self, log):
    """Parse an EVT log file. Return an EvtLog object."""
        return 0

    def exportCSV(self, log, csvFile):
    """Export an EVT log to a CSV file. Returns the number of bytes written."""
        return 0

    def getName(self):
        return _name
